From 70ebfaf596ad7c138d47d49313f33466393c2ede Mon Sep 17 00:00:00 2001
From: OpenEmbedded <oe.patch@oe>
Date: Wed, 7 Dec 2022 14:41:16 +0800
Subject: [PATCH 1/1] roll-back-the-ipmi-driver-to-2.10

---
 .../boot/dts/aspeed-bmc-inventec-superion.dts |  621 +++++++++
 drivers/char/ipmi/kcs_bmc_aspeed.c            |    2 +-
 drivers/virtual/Makefile                      |    2 +
 drivers/virtual/virtual.c                     | 1136 +++++++++++++++++
 drivers/virtual/virtual.h                     |   81 ++
 5 files changed, 1841 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/boot/dts/aspeed-bmc-inventec-superion.dts
 create mode 100644 drivers/virtual/Makefile
 create mode 100644 drivers/virtual/virtual.c
 create mode 100644 drivers/virtual/virtual.h

diff --git a/arch/arm/boot/dts/aspeed-bmc-inventec-superion.dts b/arch/arm/boot/dts/aspeed-bmc-inventec-superion.dts
new file mode 100644
index 000000000000..4c6e29bf4866
--- /dev/null
+++ b/arch/arm/boot/dts/aspeed-bmc-inventec-superion.dts
@@ -0,0 +1,621 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+// Copyright 2019 IBM Corp.
+
+/dts-v1/;
+
+#include "aspeed-g6.dtsi"
+#include "aspeed-g6-pinctrl.dtsi"
+#include <dt-bindings/i2c/i2c.h>
+#include <dt-bindings/gpio/aspeed-gpio.h>
+
+/ {
+        model = "SUPERION BMC";
+        compatible = "inventec,superion-bmc", "aspeed,ast2600";
+
+        aliases {
+                serial4 = &uart5;
+        };
+
+        chosen {
+                stdout-path = &uart5;
+                bootargs = "console=tty0 console=ttyS4,115200n8 root=/dev/ram rw init=/linuxrc";
+        };
+
+        memory@80000000 {
+                device_type = "memory";
+                reg = <0x80000000 0x80000000>;
+        };
+
+        reserved-memory {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                ranges;
+
+                gfx_memory: framebuffer {
+                        size = <0x01000000>;
+                        alignment = <0x01000000>;
+                        compatible = "shared-dma-pool";
+                        reusable;
+                };
+
+                video_engine_memory: jpegbuffer {
+                        size = <0x04000000>; /*64MB*/
+                        alignment = <0x01000000>;
+                        compatible = "shared-dma-pool";
+                        reusable;
+                };
+
+                ssp_memory: ssp_memory {
+                        size = <0x00200000>;
+                        alignment = <0x00100000>;
+                        compatible = "shared-dma-pool";
+                        no-map;
+                };
+#if 0
+                espi_peripheral_memory: espi_peripheral_memory {
+                        no-map;
+                        reg = <0x98000000 0x04000000>; /* 64M */
+                        size = <0x01000000>;
+                        alignment = <0x01000000>;
+                        compatible = "shared-dma-pool";
+                        reusable;
+                };
+#endif
+        };
+        
+        vga-shared-memory {
+                compatible = "aspeed,ast2500-vga-sharedmem";
+                reg = <0xbff00000 0x10000>;
+        };
+
+        iio-hwmon {
+                compatible = "iio-hwmon";
+                io-channels = <&adc0 0>, <&adc0 1>, <&adc0 2>, <&adc0 3>,
+                <&adc0 4>;
+        };
+
+        leds {
+                compatible = "gpio-leds";
+
+                // UID led
+                uid {
+                        label = "UID_LED";
+                        gpios = <&gpio0 ASPEED_GPIO(X, 2) GPIO_ACTIVE_LOW>;
+                };
+
+                // Heart beat led
+                heartbeat {
+                        label = "HB_LED";
+                        gpios = <&gpio0 ASPEED_GPIO(P, 7) GPIO_ACTIVE_LOW>;
+                };
+        };
+
+        ahb {
+                cvic: copro-interrupt-controller@1e6c0000 {
+                        compatible = "aspeed,ast2600-cvic", "aspeed-cvic";
+                        valid-sources = <0xffffffff>;
+                        copro-sw-interrupts = <1>;
+                        reg = <0x1e6c0000 0x80>;
+                };
+
+                sram: sram@10000000 {
+                        compatible = "mmio-sram";
+                        /* the first 64K is with parity check */
+                        reg = <0x10000000 0x16000>;
+                };
+        };
+};
+
+&mdio0 {
+        status = "okay";
+
+        ethphy0: ethernet-phy@0 {
+                compatible = "ethernet-phy-ieee802.3-c22";
+                reg = <1>;
+        };
+};
+
+&mac3 {
+        status = "okay";
+
+        phy-mode = "rgmii";
+        phy-handle = <&ethphy0>;
+
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_rgmii4_default>;
+};
+
+&fmc {
+        status = "okay";
+        flash@0 {
+                status = "okay";
+                m25p,fast-read;
+                label = "bmc";
+                spi-max-frequency = <33000000>;
+                spi-tx-bus-width = <2>;
+                spi-rx-bus-width = <2>;
+                partitions {
+                        compatible = "fixed-partitions";
+                        #address-cells = <0x1>;
+                        #size-cells = <0x1>;
+
+                        u-boot@0 {
+                                reg = <0x0 0xe0000>;
+                                label = "u-boot";
+                        };
+
+                        u-boot-env@e0000 {
+                                reg = <0xe0000 0x20000>;
+                                label = "u-boot-env";
+                        };
+
+                        kernel@100000 {
+                                reg = <0x100000 0x900000>;
+                                label = "kernel";
+                        };
+
+                        rofs@a00000 {
+                                reg = <0xa00000 0x2000000>;
+                                label = "rofs";
+                        };
+
+                        rwfs@2a00000 {
+                                reg = <0x2a00000 0x1600000>;
+                                label = "rwfs";
+                        };
+                };
+        };
+
+        flash@1 {
+                status = "okay";
+                m25p,fast-read;
+                label = "bmc2";
+                spi-max-frequency = <33000000>;
+                spi-tx-bus-width = <2>;
+                spi-rx-bus-width = <2>;
+        };
+};
+
+&spi1 {
+        status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_spi1_default>;
+        flash@0 {
+                status = "okay";
+                m25p,fast-read;
+                label = "bios";
+                spi-max-frequency = <33000000>;
+                spi-tx-bus-width = <1>;
+                spi-rx-bus-width = <1>;
+        };
+};
+
+&wdt1 {
+        status = "okay";
+};
+
+&wdt2 {
+        status = "okay";
+};
+
+&uart1 {
+        status = "okay";
+};
+
+&uart3 {
+        status = "okay";
+};
+
+&uart5 {
+        status = "okay";
+};
+
+&uart_routing {
+	status = "okay";
+};
+
+&i2c0 {
+        status = "okay";
+
+        //Set bmc' slave address;
+        bmc_slave@10 {
+                compatible = "ipmb-dev";
+                reg = <(0x10 | I2C_OWN_SLAVE_ADDRESS)>;
+                i2c-protocol;
+        };
+};
+
+&i2c2 {
+        status = "okay";
+};
+
+&i2c3 {
+        // FRU AT24C512C-SSHM-T
+        status = "okay";
+        eeprom@50 {
+                compatible = "atmel,24c512";
+                reg = <0x50>;
+                pagesize = <128>;
+        };
+};
+
+&i2c5 {
+        status = "okay";
+};
+
+&i2c6 {
+        status = "okay";
+        tmp75@49 {
+                compatible = "ti,tmp75";
+                reg = <0x49>;
+        };
+
+        tmp75@4f {
+                compatible = "ti,tmp75";
+                reg = <0x4f>;
+        };
+
+        tmp468@48 {
+                compatible = "ti,tmp468";
+                reg = <0x48>;
+        };
+};
+
+&i2c7 {
+        status = "okay";
+        adm1278@40 {
+                compatible = "adi,adm1278";
+                reg = <0x40>;
+        };
+};
+
+
+&i2c8 {
+        // FRU AT24C512C-SSHM-T
+        status = "okay";
+        eeprom@51 {
+                compatible = "atmel,24c512";
+                reg = <0x51>;
+                pagesize = <128>;
+        };
+
+        eeprom@53 {
+                compatible = "atmel,24c512";
+                reg = <0x53>;
+                pagesize = <128>;
+        };
+};
+
+&i2c9 {
+        // M.2
+        status = "okay";
+};
+
+&i2c10 {
+        // I2C EXPANDER
+        status = "okay";
+        i2c-switch@71 {
+                compatible = "nxp,pca9546";
+                #address-cells = <1>;
+                #size-cells = <0>;
+                reg = <0x71>;
+        };
+
+        i2c-switch@73 {
+                compatible = "nxp,pca9546";
+                #address-cells = <1>;
+                #size-cells = <0>;
+                reg = <0x73>;
+        };
+};
+
+&i2c11 {
+        // I2C EXPANDER
+        status = "okay";
+        i2c-switch@70 {
+                compatible = "nxp,pca9546";
+                #address-cells = <1>;
+                #size-cells = <0>;
+                reg = <0x70>;
+
+                pcie_eeprom_riser1: i2c@0 {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        reg = <0>;
+
+                        eeprom@55 {
+                                compatible = "atmel,24c512";
+                                reg = <0x55>;
+                                pagesize = <128>;
+                        };
+                };
+                pcie_eeprom_riser2: i2c@2 {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        reg = <2>;
+
+                        eeprom@55 {
+                                compatible = "atmel,24c512";
+                                reg = <0x55>;
+                                pagesize = <128>;
+                        };
+                };
+
+                pcie_eeprom_riser3: i2c@3 {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        reg = <3>;
+
+                        eeprom@55 {
+                                compatible = "atmel,24c512";
+                                reg = <0x55>;
+                                pagesize = <128>;
+                        };
+                };
+        };
+};
+
+&i2c12 {
+        status = "okay";
+        psu0:psu0@58 {
+                compatible = "pmbus";
+                reg = <0x58>;
+        };
+};
+
+&pwm_tacho {
+        status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm0_default &pinctrl_tach0_default
+                        &pinctrl_pwm1_default &pinctrl_tach1_default
+                        &pinctrl_pwm2_default &pinctrl_tach2_default
+                        &pinctrl_pwm3_default &pinctrl_tach3_default
+                        &pinctrl_pwm4_default &pinctrl_tach4_default
+                        &pinctrl_pwm5_default &pinctrl_tach5_default
+                        &pinctrl_pwm6_default &pinctrl_tach6_default
+                        &pinctrl_pwm7_default &pinctrl_tach7_default
+                                              &pinctrl_tach8_default
+                                              &pinctrl_tach9_default
+                                              &pinctrl_tach10_default
+                                              &pinctrl_tach11_default
+                                              &pinctrl_tach12_default
+                                              &pinctrl_tach13_default
+                                              &pinctrl_tach14_default
+                                              &pinctrl_tach15_default>;
+     fan@0 {
+     reg = <0x00>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x00>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@1 {
+     reg = <0x01>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x01>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@2 {
+     reg = <0x02>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x02>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@3 {
+     reg = <0x03>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x03>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@4 {
+     reg = <0x04>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x04>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@5 {
+     reg = <0x05>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x05>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@6 {
+     reg = <0x06>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x06>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@7 {
+     reg = <0x07>;
+     aspeed,target_pwm = <25000>;
+     cooling-levels = <125 151 177 203 229 255>;
+     aspeed,fan-tach-ch = <0x07>;
+     aspeed,min_rpm = <750000>;
+     };
+
+     fan@8 {
+     reg = <0x08>;
+     aspeed,fan-tach-ch = <0x08>;
+     };
+
+     fan@9 {
+     reg = <0x09>;
+     aspeed,fan-tach-ch = <0x09>;
+     };
+
+     fan@10 {
+     reg = <0x0a>;
+     aspeed,fan-tach-ch = <0x0a>;
+     };
+
+     fan@11 {
+     reg = <0x0b>;
+     aspeed,fan-tach-ch = <0x0b>;
+     };
+
+     fan@12 {
+     reg = <0x0c>;
+     aspeed,fan-tach-ch = <0x0c>;
+     };
+
+     fan@13 {
+     reg = <0x0d>;
+     aspeed,fan-tach-ch = <0x0d>;
+     };
+
+     fan@14 {
+     reg = <0x0e>;
+     aspeed,fan-tach-ch = <0x0e>;
+     };
+
+     fan@15 {
+     reg = <0x0f>;
+     aspeed,fan-tach-ch = <0x0f>;
+     };
+
+};
+
+&gpio0 {
+        status = "okay";
+        gpio-line-names =
+        /*A0-A7*/   "","","","","","","","",
+        /*B0-B7*/   "I2C_HSC_ALERT","BMC_READY","","","","","PSU1_ALERT","",
+        /*C0-C7*/   "","","","","","","","",
+        /*D0-D7*/   "","","","","","","","",
+        /*E0-E7*/   "","","","","","","","",
+        /*F0-F7*/   "","","","","RST_BMC_SGPIO","","","",
+        /*G0-G7*/   "","","JTAG_MUX_SEL","","","","","",
+        /*H0-H7*/   "","","","","RESET_OUT","POWER_OUT","","",
+        /*I0-I7*/   "","","","","","","NMI_OUT","",
+        /*J0-J7*/   "","","","","","","","",
+        /*K0-K7*/   "","","","","","","","",
+        /*L0-L7*/   "","","","","","","","",
+        /*M0-M7*/   "","","","","","","","",
+        /*N0-N7*/   "PCH_SMI_ACTIVE_N","","","","","","","",
+        /*O0-O7*/   "","","","","","","","",
+        /*P0-P7*/   "","","","TCK_MUX_SEL","BMC_ASD_JTAG_EN","","PREQ_N","",
+        /*Q0-Q7*/   "","","","","","","","",
+        /*R0-R7*/   "","","","","","","","",
+        /*S0-S7*/   "","","","","","","PCH_THERMTRIP","",
+        /*T0-T7*/   "","","","","","","","",
+        /*U0-U7*/   "","NMI_BUTTON","","","","","","",
+        /*V0-V7*/   "","","","","PS_PWROK","","","PRDY_N",
+        /*W0-W7*/   "","","","","","","","",
+        /*X0-X7*/   "","","","CPLD_CATERR","","","","",
+        /*Y0-Y7*/   "","","","","","","","",
+        /*Z0-Z7*/   "","","","","","","","",
+        /*AA0-AA7*/ "","","","","","","","",
+        /*AB0-AB7*/ "","","","","","","","",
+        /*AC0-AC7*/ "","","","","","","","";
+};
+
+&sgpiom0 {
+        status = "okay";
+        max-ngpios = <40>;
+        ngpios = <40>;
+        bus-frequency = <1000000>;
+        gpio-line-names =
+        /*in - out - in - out */
+        /*A0-A7*/ "CPU1_MEMTRIP_N","","CPU_ERROR0_N","","CPU_ERROR1_N","","CPU_ERROR2_N","",
+        /*A0-A7*/ "MIPI_PRSNT_BMC","","PCH_HOT_N","","","","BIOS_POST_CMPLT_N","",
+        /*B0-B7*/ "PROC1MEM_VRHOT_N","","PROC0_MEMHOT_OUT_N","","PROC1_MEMHOT_OUT_N","","CPU0_PROCHOT_N","",
+        /*B0-B7*/ "CPU1_PROCHOT_N","","CPU0_THERMTRIP_N","","CPU1_THERMTRIP_N","","CPU0_MEMTRIP_N","",
+        /*C0-C7*/ "CPU_PWR_FAIL","","DIMM_MODULE_POWER_FAIL","","","","PCH_PWR_FAIL","",
+        /*C0-C7*/ "","","PROC0_VRHOT_N","","PROC1_VRHOT_N","","PROC0MEM_VRHOT_N","",
+        /*D0-D7*/ "","","","","NMI_SW","","INTRUDER","",
+        /*D0-D7*/ "","","","","","","MEM_CONTROLLER_PWR_FAIL","",
+        /*E0-E7*/ "","","","","","","","",
+        /*E0-E7*/ "","","","","","","","";
+};
+
+&peci{
+        peci0: peci-bus@0{
+                status = "okay";
+
+                peci-client@30 {
+                        compatible = "intel,peci-client";
+                        reg = <0x30>;
+                };
+
+                peci-client@31 {
+                        compatible = "intel,peci-client";
+                        reg = <0x31>;
+                };
+        };
+};
+
+&jtag0 {
+        status = "okay";
+};
+
+&jtag1 {
+        status = "okay";
+};
+
+&adc0 {
+        ref_voltage = <2500>;
+        status = "okay";
+
+        pinctrl-0 = <&pinctrl_adc0_default &pinctrl_adc1_default
+                &pinctrl_adc2_default &pinctrl_adc3_default
+                &pinctrl_adc4_default>;
+};
+
+&espi {
+        status = "okay";
+};
+
+&lpc_snoop {
+        status = "okay";
+        snoop-ports = <0x80>;
+};
+
+&emmc_controller {
+        status = "okay";
+        timing-phase = <0x700FF>;
+};
+
+&emmc {
+        status = "okay";
+
+        non-removable;
+        max-frequency = <52000000>;
+        sdhci-drive-type = /bits/ 8 <3>;
+#if 0
+        bus-width = <4>;
+#else
+        bus-width = <8>;
+        pinctrl-0 = <&pinctrl_emmc_default
+                        &pinctrl_emmcg8_default>;
+#endif
+};
+
+&vhub {
+        status = "okay";
+        aspeed,vhub-downstream-ports = <7>;
+        aspeed,vhub-generic-endpoints = <21>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usb2ad_default>;
+};
+
+&rtc {
+        status = "okay";
+};
+
+&video {
+        status = "okay";
+        memory-region = <&video_engine_memory>;
+};
diff --git a/drivers/char/ipmi/kcs_bmc_aspeed.c b/drivers/char/ipmi/kcs_bmc_aspeed.c
index 22c1526c2cf5..c75a4e6927d2 100755
--- a/drivers/char/ipmi/kcs_bmc_aspeed.c
+++ b/drivers/char/ipmi/kcs_bmc_aspeed.c
@@ -277,7 +277,7 @@ static int aspeed_kcs_calculate_channel(const struct kcs_ioreg *regs)
 
 	for (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i) {
 		if (!memcmp(&ast_kcs_bmc_ioregs[i], regs, sizeof(*regs)))
-			return i  1;
+			return i;
  	}
 
 
diff --git a/drivers/virtual/Makefile b/drivers/virtual/Makefile
new file mode 100644
index 000000000000..ac47ba9c44b9
--- /dev/null
+++ b/drivers/virtual/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIRTUAL)		+= virtual.o
+
diff --git a/drivers/virtual/virtual.c b/drivers/virtual/virtual.c
new file mode 100644
index 000000000000..5450e4f27654
--- /dev/null
+++ b/drivers/virtual/virtual.c
@@ -0,0 +1,1136 @@
+/*
+*  Inventec virtual hwmon driver
+*
+*/
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/util_macros.h>
+#include "virtual.h"
+
+
+static virtual_hwmon_temp_params_t device_params_temp = {
+	.value1 = 0,
+	.value2 = 0,
+	.value3 = 0,
+	.value4 = 0,
+	.value5 = 0,
+	.value6 = 0,
+	.value7 = 0,
+	.value8 = 0,
+	.value9 = 0,
+};
+
+static virtual_hwmon_eeprom_params_t device_params_eeprom = {
+	.data = {
+			0x01, 0x00, 0x01, 0x04, 0x0c, 0x12, 0x00, 0xdc, 0x01, 0x03, 0x1d, 0xc3, 0x4e, 0x2f, 0x41, 0xc3,
+			0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f, 0x41, 0xc1, 0x00, 0x00, 0x00, 0x1a,
+			0x01, 0x08, 0x19, 0xb0, 0xb2, 0xc1, 0xca, 0x49, 0x6e, 0x76, 0x65, 0x6e, 0x74, 0x65, 0x63, 0x20,
+			0x20, 0xc5, 0x53, 0x43, 0x4d, 0x20, 0x20, 0xca, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+			0x20, 0x20, 0xcc, 0x31, 0x33, 0x39, 0x35, 0x41, 0x33, 0x32, 0x30, 0x39, 0x33, 0x30, 0x31, 0xc9,
+			0x46, 0x52, 0x55, 0x20, 0x76, 0x30, 0x2e, 0x30, 0x39, 0xc4, 0x41, 0x20, 0x20, 0x20, 0xc1, 0x09,
+			0x01, 0x06, 0x19, 0xc9, 0x49, 0x6e, 0x76, 0x65, 0x6e, 0x74, 0x65, 0x63, 0x20, 0xc3, 0x53, 0x43,
+			0x4d, 0xc3, 0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f,
+			0x41, 0xc2, 0x30, 0x20, 0xc3, 0x4e, 0x2f, 0x41, 0xc3, 0x4e, 0x2f, 0x41, 0xc1, 0x00, 0x00, 0x3c,	
+		}
+};
+
+static virtual_hwmon_psu_params_t device_params_psu = {
+	.in1_input = 0,
+	.in2_input = 0,
+	.curr1_input = 0,
+	.curr2_input = 0,
+	.power1_input = 0,
+	.power2_input = 0,
+	.fan1_input = 0,
+	.fan2_input = 0,
+	.pwm1_input = 0,
+};
+
+static virtual_hwmon_fan_params_t device_params_fan = {
+	.fan1_input = 0,
+	.fan2_input = 0,
+	.fan3_input = 0,
+	.fan4_input = 0,
+	.fan1_target = 0,
+	.fan2_target = 0,
+	.fan3_target = 0,
+	.fan4_target = 0,
+	.fan1_fault = 0,
+	.fan2_fault = 0,
+	.fan3_fault = 0,
+	.fan4_fault = 0,
+	.pwm1_input = 0,
+	.pwm2_input = 0,
+	.pwm1_enable = 0,
+	.pwm2_enable = 0,
+};
+
+
+static const struct i2c_device_id virtual_hwmon_ids[] = {
+	{ "virtual_temp", VIRTUAL_TEMP, },
+	{ "virtual_eeprom", VIRTUAL_EEPROM, },
+	{ "virtual_psu", VIRTUAL_PSU, },
+	{ "virtual_fan", VIRTUAL_FAN, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, virtual_hwmon_ids);
+
+static const struct of_device_id __maybe_unused virtual_hwmon_of_match[] = {
+	{
+		.compatible = "inventec,virtual_temp",
+		.data = (void *)VIRTUAL_TEMP
+	},
+	{
+		.compatible = "inventec,virtual_eeprom",
+		.data = (void *)VIRTUAL_EEPROM
+	},
+	{
+		.compatible = "inventec,virtual_psu",
+		.data = (void *)VIRTUAL_PSU
+	},
+	{
+		.compatible = "inventec,virtual_fan",
+		.data = (void *)VIRTUAL_FAN
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, virtual_hwmon_of_match);
+
+
+
+
+static umode_t virtual_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+			       u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_input:
+			return 0644;
+		}
+		break;
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+			return 0644;
+		case hwmon_in_label:
+			return 0444;
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_input:
+			return 0644;
+		case hwmon_curr_label:
+			return 0444;
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_input:
+			return 0644;
+		case hwmon_power_label:
+			return 0444;
+		}
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+		case hwmon_fan_label:
+			return 0444;
+		case hwmon_fan_target:
+		case hwmon_fan_fault:
+			return 0644;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+		case hwmon_pwm_enable:
+			return 0644;
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+
+static int virtual_hwmon_temp_read(struct device *dev, enum hwmon_sensor_types type,
+		     u32 attr, int channel, long *val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_temp_params_t *para = data->params;
+
+	switch (attr) {
+	case hwmon_temp_input:
+		switch(channel) {
+		case 0:
+			*val = para->value1;
+			break;
+		case 1:
+			*val = para->value2;
+			break;
+		case 2:
+			*val = para->value3;
+			break;
+		case 3:
+			*val = para->value4;
+			break;
+		case 4:
+			*val = para->value5;
+			break;
+		case 5:
+			*val = para->value6;
+			break;
+		case 6:
+			*val = para->value7;
+			break;
+		case 7:
+			*val = para->value8;
+			break;
+		case 8:
+			*val = para->value9;
+			break;
+		default:
+			dev_info(dev, "hwmon temp not support channel %d\n", channel);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon temp not support attr %d\n", attr);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int virtual_hwmon_temp_write(struct device *dev, enum hwmon_sensor_types type,
+		      u32 attr, int channel, long val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_temp_params_t *para = data->params;
+
+
+	switch (attr) {
+	case hwmon_temp_input:
+		switch(channel) {
+		case 0:
+			para->value1 = val;
+			break;
+		case 1:
+			para->value2 = val;
+			break;
+		case 2:
+			para->value3 = val;
+			break;
+		case 3:
+			para->value4 = val;
+			break;
+		case 4:
+			para->value5 = val;
+			break;
+		case 5:
+			para->value6 = val;
+			break;
+		case 6:
+			para->value7 = val;
+			break;
+		case 7:
+			para->value8 = val;
+			break;
+		case 8:
+			para->value9 = val;
+			break;
+		default:
+			dev_info(dev, "hwmon temp not support channel %d\n", channel);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon temp not support attr %d\n", attr);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static ssize_t virtual_eeprom_read(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr,
+			   char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	virtual_hwmon_data_t *data = i2c_get_clientdata(client);
+	virtual_hwmon_eeprom_params_t *para = data->params;
+
+	memcpy(buf, &para->data[off], count);
+
+	return count;
+}
+
+
+static ssize_t virtual_eeprom_write(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr,
+			   char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(kobj_to_dev(kobj));
+	virtual_hwmon_data_t *data = i2c_get_clientdata(client);
+	virtual_hwmon_eeprom_params_t *para = data->params;
+
+	memcpy(&para->data[off],buf, count);
+
+	return count;
+}
+
+static int virtual_pwm_to_main_fan_input(u8 pwm, long *main_input)
+{
+	if(pwm == 0) {
+		*main_input = 0;
+	} else {
+		*main_input = 1000 + pwm * 100;
+	}
+	return 0;
+}
+
+static int virtual_pwm_to_sub_fan_input(u8 pwm, long *sub_input)
+{
+	if(pwm == 0) {
+		*sub_input = 0;
+	} else {
+		*sub_input = 500 + pwm * 60;
+	}
+	return 0;
+}
+
+static int virtual_hwmon_psu_read(struct device *dev, enum hwmon_sensor_types type,
+		     u32 attr, int channel, long *val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_psu_params_t *para = data->params;
+
+	switch (type) {
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+			switch(channel) {
+			case 0:
+				*val = para->in1_input;
+				break;
+			case 1:
+				*val = para->in2_input;
+				break;
+			case 2:
+				*val = para->in3_input;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_input:
+			switch(channel) {
+			case 0:
+				*val = para->curr1_input;
+				break;
+			case 1:
+				*val = para->curr2_input;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_input:
+			switch(channel) {
+			case 0:
+				*val = para->power1_input;
+				break;
+			case 1:
+				*val = para->power2_input;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			switch(channel) {
+			case 0:
+				return virtual_pwm_to_main_fan_input( para->pwm1_input, val);
+			case 1:
+				return virtual_pwm_to_sub_fan_input( para->pwm1_input, val);
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			switch(channel) {
+			case 0:
+				*val = para->pwm1_input;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_input:
+			switch(channel) {
+			case 0:
+				*val = para->temp1_input;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon psu not support type %d\n", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+
+
+static const char *const virtual_hwmon_psu_in_labels[] = {
+	"pending",
+	"vin",
+	"vout1",
+};
+
+static const char *const virtual_hwmon_psu_curr_labels[] = {
+	"iout1",
+	"pending",
+};
+
+static const char *const virtual_hwmon_psu_power_labels[] = {
+	"pin",
+	"pending",
+};
+
+static int virtual_hwmon_psu_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,
+		    int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_label:
+			*str = virtual_hwmon_psu_in_labels[channel];
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_label:
+			*str = virtual_hwmon_psu_curr_labels[channel];
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_label:
+			*str = virtual_hwmon_psu_power_labels[channel];
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+
+static int virtual_hwmon_psu_write(struct device *dev, enum hwmon_sensor_types type,
+		      u32 attr, int channel, long val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_psu_params_t *para = data->params;
+
+	switch (type) {
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+			switch(channel) {
+			case 0:
+				para->in1_input = val;
+				break;
+			case 1:
+				para->in2_input = val;
+				break;
+			case 2:
+				para->in3_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_input:
+			switch(channel) {
+			case 0:
+				para->curr1_input = val;
+				break;
+			case 1:
+				para->curr2_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_input:
+			switch(channel) {
+			case 0:
+				para->power1_input = val;
+				break;
+			case 1:
+				para->power2_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			dev_info(dev, "Please use pwm to set fan input\n");
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			switch(channel) {
+			case 0:
+				para->pwm1_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_input:
+			switch(channel) {
+			case 0:
+				para->temp1_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon psu not support type %d\n", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int virtual_hwmon_fan_read(struct device *dev, enum hwmon_sensor_types type,
+		     u32 attr, int channel, long *val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_fan_params_t *para = data->params;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			switch(channel) {
+			case 0:
+				return virtual_pwm_to_main_fan_input( para->pwm1_input, val);
+			case 1:
+				return virtual_pwm_to_sub_fan_input( para->pwm1_input, val);
+			case 2:
+				return virtual_pwm_to_main_fan_input( para->pwm2_input, val);
+			case 3:
+				return virtual_pwm_to_sub_fan_input( para->pwm2_input, val);
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		case hwmon_fan_target:
+			switch(channel) {
+			case 0:
+				*val = para->fan1_target;
+				break;
+			case 1:
+				*val = para->fan2_target;
+				break;
+			case 2:
+				*val = para->fan3_target;
+				break;
+			case 3:
+				*val = para->fan4_target;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		case hwmon_fan_fault:
+			switch(channel) {
+			case 0:
+				*val = para->fan1_fault;
+				break;
+			case 1:
+				*val = para->fan2_fault;
+				break;
+			case 2:
+				*val = para->fan3_fault;
+				break;
+			case 3:
+				*val = para->fan4_fault;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon fan not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			switch(channel) {
+			case 0:
+				*val = para->pwm1_input;
+				break;
+			case 1:
+				*val = para->pwm2_input;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		case hwmon_pwm_enable:
+			switch(channel) {
+			case 0:
+				*val = para->pwm1_enable;
+				break;
+			case 1:
+				*val = para->pwm2_enable;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon fan not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon fan not support type %d\n", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int virtual_hwmon_fan_write(struct device *dev, enum hwmon_sensor_types type,
+		      u32 attr, int channel, long val)
+{
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	virtual_hwmon_fan_params_t *para = data->params;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			dev_info(dev, "Please use pwm to set fan input\n");
+			break;
+		case hwmon_fan_target:
+			switch(channel) {
+			case 0:
+				para->fan1_target = val;
+				break;
+			case 1:
+				para->fan2_target = val;
+				break;
+			case 2:
+				para->fan3_target = val;
+				break;
+			case 3:
+				para->fan4_target = val;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		case hwmon_fan_fault:
+			switch(channel) {
+			case 0:
+				para->fan1_fault = val;
+				break;
+			case 1:
+				para->fan2_fault = val;
+				break;
+			case 2:
+				para->fan3_fault = val;
+				break;
+			case 3:
+				para->fan4_fault = val;
+				break;
+			default:
+				dev_info(dev, "hwmon fan not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon fan not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			switch(channel) {
+			case 0:
+				para->pwm1_input = val;
+				break;
+			case 1:
+				para->pwm2_input = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		case hwmon_pwm_enable:
+			switch(channel) {
+			case 0:
+				para->pwm1_enable = val;
+				break;
+			case 1:
+				para->pwm2_enable = val;
+				break;
+			default:
+				dev_info(dev, "hwmon psu not support channel %d\n", channel);
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_info(dev, "hwmon psu not support attr %d\n", attr);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_info(dev, "hwmon psu not support type %d\n", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*************************/
+
+static const struct hwmon_channel_info *virtual_hwmon_temp_info[] = {
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT,
+			   HWMON_T_INPUT),
+	NULL
+};
+
+static const struct hwmon_ops virtual_hwmon_temp_ops = {
+	.is_visible = virtual_hwmon_is_visible,
+	.read = virtual_hwmon_temp_read,
+	.write = virtual_hwmon_temp_write,
+};
+
+static const struct hwmon_chip_info virtual_hwmon_temp_chip_info = {
+	.ops = &virtual_hwmon_temp_ops,
+	.info = virtual_hwmon_temp_info,
+};
+
+
+static const struct bin_attribute virtual_eeprom_attr = {
+	.attr = {
+		.name = "eeprom",
+		.mode = S_IRUGO|S_IWUGO ,
+	},
+	.size = VIRTUAL_EEPROM_SIZE,
+	.read = virtual_eeprom_read,
+	.write = virtual_eeprom_write,
+};
+
+
+static const struct hwmon_channel_info *virtual_hwmon_psu_info[] = {
+	HWMON_CHANNEL_INFO(in,
+			   HWMON_I_INPUT|HWMON_I_LABEL,
+			   HWMON_I_INPUT|HWMON_I_LABEL,
+			   HWMON_I_INPUT|HWMON_I_LABEL),
+	HWMON_CHANNEL_INFO(curr,
+			   HWMON_C_INPUT|HWMON_C_LABEL,
+			   HWMON_C_INPUT|HWMON_C_LABEL),
+	HWMON_CHANNEL_INFO(power,
+			   HWMON_P_INPUT|HWMON_P_LABEL,
+			   HWMON_P_INPUT|HWMON_P_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT,
+			   HWMON_F_INPUT),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_INPUT),
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_PWM_INPUT),
+	NULL
+};
+
+static const struct hwmon_ops virtual_hwmon_psu_ops = {
+	.is_visible = virtual_hwmon_is_visible,
+	.read = virtual_hwmon_psu_read,
+	.read_string = virtual_hwmon_psu_read_string,
+	.write = virtual_hwmon_psu_write,
+};
+
+static const struct hwmon_chip_info virtual_hwmon_psu_chip_info = {
+	.ops = &virtual_hwmon_psu_ops,
+	.info = virtual_hwmon_psu_info,
+};
+
+static const struct hwmon_channel_info *virtual_hwmon_fan_info[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT|HWMON_F_TARGET|HWMON_F_FAULT,
+			   HWMON_F_INPUT|HWMON_F_TARGET|HWMON_F_FAULT,
+			   HWMON_F_INPUT|HWMON_F_TARGET|HWMON_F_FAULT,
+			   HWMON_F_INPUT|HWMON_F_TARGET|HWMON_F_FAULT),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_INPUT|HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT|HWMON_PWM_ENABLE),
+	NULL
+};
+
+static const struct hwmon_ops virtual_hwmon_fan_ops = {
+	.is_visible = virtual_hwmon_is_visible,
+	.read = virtual_hwmon_fan_read,
+	.write = virtual_hwmon_fan_write,
+};
+
+static const struct hwmon_chip_info virtual_hwmon_fan_chip_info = {
+	.ops = &virtual_hwmon_fan_ops,
+	.info = virtual_hwmon_fan_info,
+};
+
+
+/*******
+  Remove
+*******/
+
+static int virtual_hwmon_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	virtual_hwmon_data_t *data = dev_get_drvdata(dev);
+	int err = 0;
+
+	switch(data->kind)
+	{
+	case VIRTUAL_TEMP:
+		break;
+	case VIRTUAL_EEPROM:
+		sysfs_remove_bin_file(&client->dev.kobj, &virtual_eeprom_attr);
+		break;
+	case VIRTUAL_PSU:
+		break;
+	case VIRTUAL_FAN:
+		break;
+	default:
+		dev_info(dev, "sensor '%s' not support kind %d\n", client->name, data->kind);
+		err = -EINVAL;
+		break;
+	}
+
+	dev_info(dev, "sensor '%s'\n", client->name);
+
+	return err;
+}
+
+
+/*******
+  Probe
+*******/
+
+static int
+virtual_temp_probe(struct i2c_client *client )
+{
+	struct device *dev = &client->dev;
+	struct device *hwmon_dev;
+	virtual_hwmon_data_t *data;
+	int err;
+
+	err = 0;
+
+	data = devm_kzalloc(dev, sizeof(virtual_hwmon_data_t), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	data->client = client;
+	data->kind = VIRTUAL_TEMP;
+	data->params = &device_params_temp;
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,
+							 data, &virtual_hwmon_temp_chip_info,
+							 NULL);
+
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	dev_info(dev, "%s: sensor '%s'\n", dev_name(hwmon_dev), client->name);
+
+	return err;
+}
+
+static int
+virtual_eeprom_probe(struct i2c_client *client )
+{
+	struct device *dev = &client->dev;
+	virtual_hwmon_data_t *data;
+
+	data = devm_kzalloc(dev, sizeof(virtual_hwmon_data_t), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	data->client = client;
+	data->kind = VIRTUAL_EEPROM;
+	data->params = &device_params_eeprom;
+
+	i2c_set_clientdata(client, data);
+
+	/* create the sysfs eeprom file */
+	return sysfs_create_bin_file(&client->dev.kobj, &virtual_eeprom_attr);
+}
+
+
+static int
+virtual_psu_probe(struct i2c_client *client )
+{
+	struct device *dev = &client->dev;
+	struct device *hwmon_dev;
+	virtual_hwmon_data_t *data;
+	int err;
+
+	err = 0;
+
+	data = devm_kzalloc(dev, sizeof(virtual_hwmon_data_t), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	data->client = client;
+	data->kind = VIRTUAL_PSU;
+	data->params = &device_params_psu;
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,
+							 data, &virtual_hwmon_psu_chip_info,
+							 NULL);
+
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	dev_info(dev, "%s: sensor '%s'\n", dev_name(hwmon_dev), client->name);
+
+	return err;
+}
+
+static int
+virtual_fan_probe(struct i2c_client *client )
+{
+	struct device *dev = &client->dev;
+	struct device *hwmon_dev;
+	virtual_hwmon_data_t *data;
+	int err;
+
+	err = 0;
+
+	data = devm_kzalloc(dev, sizeof(virtual_hwmon_data_t), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	data->client = client;
+	data->kind = VIRTUAL_FAN;
+	data->params = &device_params_fan;
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,
+							 data, &virtual_hwmon_fan_chip_info,
+							 NULL);
+
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	dev_info(dev, "%s: sensor '%s'\n", dev_name(hwmon_dev), client->name);
+
+	return err;
+}
+
+
+static int
+virtual_hwmon_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	virtual_hwmon_type_enum kind;
+	int err;
+
+	err = 0;
+
+	if (client->dev.of_node)
+		kind = (virtual_hwmon_type_enum)of_device_get_match_data(&client->dev);
+	else
+		kind = id->driver_data;
+
+	switch (kind) {
+	case VIRTUAL_TEMP:
+		err = virtual_temp_probe(client);
+		break;
+	case VIRTUAL_EEPROM:
+		err = virtual_eeprom_probe(client);
+		break;
+	case VIRTUAL_PSU:
+		err = virtual_psu_probe(client);
+		break;
+	case VIRTUAL_FAN:
+		err = virtual_fan_probe(client);
+		break;
+	default:
+		dev_info(dev, "sensor '%s' not support kind %d\n", client->name, kind);
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+
+static struct i2c_driver virtual_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "virtual",
+		.of_match_table = of_match_ptr(virtual_hwmon_of_match),
+	},
+	.probe		= virtual_hwmon_probe,
+	.remove     = virtual_hwmon_remove,
+	.id_table	= virtual_hwmon_ids,
+};
+
+module_i2c_driver(virtual_driver);
+
+
+MODULE_AUTHOR("Inventec");
+MODULE_DESCRIPTION("virtual hwmon driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/virtual/virtual.h b/drivers/virtual/virtual.h
new file mode 100644
index 000000000000..a4fe2b0ef567
--- /dev/null
+++ b/drivers/virtual/virtual.h
@@ -0,0 +1,81 @@
+/*
+*  Inventec virtual hwmon driver
+*
+*/
+#ifndef _DRIVER_VIRTUAL_H_
+#define _DRIVER_VIRTUAL_H_
+
+#include <linux/kernel.h>
+
+#define VIRTUAL_EEPROM_SIZE		10240
+
+
+typedef enum _virtual_hwmon_type_enum {
+	VIRTUAL_TEMP,
+	VIRTUAL_EEPROM,
+	VIRTUAL_PSU,
+	VIRTUAL_FAN,
+} virtual_hwmon_type_enum;
+
+
+typedef struct _virtual_hwmon_temp_params_t {
+	long  value1;
+	long  value2;
+	long  value3;
+	long  value4;
+	long  value5;
+	long  value6;
+	long  value7;
+	long  value8;
+	long  value9;
+} virtual_hwmon_temp_params_t;
+
+typedef struct _virtual_hwmon_eeprom_params_t {
+	u8 data[VIRTUAL_EEPROM_SIZE];
+} virtual_hwmon_eeprom_params_t;
+
+typedef struct _virtual_hwmon_psu_params_t {
+	long   in1_input;
+	long   in2_input;
+	long   in3_input;
+	long   curr1_input;
+	long   curr2_input;
+	long   power1_input;
+	long   power2_input;
+	long   fan1_input;
+	long   fan2_input;
+	u8  pwm1_input;
+	long   temp1_input;
+} virtual_hwmon_psu_params_t;
+
+
+typedef struct _virtual_hwmon_fan_params_t {
+	long   fan1_input;
+	long   fan2_input;
+	long   fan3_input;
+	long   fan4_input;
+	long   fan1_target;
+	long   fan2_target;
+	long   fan3_target;
+	long   fan4_target;
+	u16    fan1_fault;
+	u16    fan2_fault;
+	u16    fan3_fault;
+	u16    fan4_fault;
+	u8     pwm1_input;
+	u8     pwm2_input;
+	u8     pwm1_enable;
+	u8     pwm2_enable;
+} virtual_hwmon_fan_params_t;
+
+
+/* Each client has this additional data */
+typedef struct _virtual_hwmon_data_t {
+	struct i2c_client  *client;
+	virtual_hwmon_type_enum  kind;
+	void  *params;
+} virtual_hwmon_data_t;
+
+
+
+#endif
-- 
2.25.1

